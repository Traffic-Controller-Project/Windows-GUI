# Form implementation generated from reading ui file '.\GUIMain.ui'
#
# Created by: PyQt6 UI code generator 6.4.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.

import json
import paho.mqtt.client as mqtt
from PyQt6 import QtCore, QtGui, QtWidgets
from MQTTBroker import client,broker,port,topics,data
from PyQt6.QtCore import *
from PyQt6.QtGui import *
from PyQt6.QtWidgets import *

treeModelsList = {}
dictSignalState = {"0":"Red","1":"Amber","2":"Green Left","3":"Green Forward","4":"Green Right"}
dictSignalIcon = {"Red":"icons/icon_red.png","Amber":"icons/icon_amber.png","Green Left":"icons/icon_greenLeft.png","Green Forward":"icons/icon_greenForward.png","Green Right":"icons/icon_greenRight.png"}
dictHigherState = {"0": "Multidirectional", "1": "Straight only"}
dictLowerState0 = {"0": "All Red, Pedestrian Green only", "1": "North Green","2": "West Green", "3": "South Green", "4": "East Green"}
dictLowerState1 = {"0": "All Red, Pedestrian Green only", "1": "North-South Green","2": "West-East Green"}
dictMasterKeys = {"n_states":'Higher State',"master_state":"Lower State","timers":"Timers for the slaves"}

#Check convertible to int
def is_convertible_to_int(string):
    try:
        int(string)
        return True
    except ValueError:
        return False

# Read JSON file
def read_json_file(file_path):
    with open(file_path, 'r') as file:
        data = json.load(file)
    return data

class Ui_MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.received_message_slave = None
        self.received_message_master = None

    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.tabWidget = QtWidgets.QTabWidget(parent=self.centralwidget)
        self.tabWidget.setObjectName("tabWidget")
        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(parent=MainWindow)
        self.statusbar.setObjectName("statusbar")
        self.statusLabel = QLabel()
        self.statusbar.addWidget(self.statusLabel)
        MainWindow.setStatusBar(self.statusbar)
        windowIcon = QtGui.QIcon()
        windowIcon.addPixmap(QtGui.QPixmap("icons/icon_trafficWindow.png"), QtGui.QIcon.Mode.Selected, QtGui.QIcon.State.On)
        MainWindow.setWindowIcon(windowIcon)
        self.createTabs()
        self.retranslateUi(MainWindow)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def createTabs(self):
        for tab in guiStructure:
            self.tab = QtWidgets.QWidget()
            self.tabWidget.addTab(self.tab, tab)
            self.gridLayout.addWidget(self.tabWidget)
            self.tab.setObjectName(tab)
            self.gridLayout_2 = QtWidgets.QGridLayout(self.tab)
            self.gridLayout_2.setObjectName("gridLayout_2")
            self.createTabStructure(self.tab,guiStructure[tab],self.gridLayout_2)

    def createTabStructure(self,tab,tabStructure,gridLayout):
        for row,groupBoxLabel in enumerate(tabStructure):
            if(groupBoxLabel == "button" and tabStructure[groupBoxLabel]["present"] == True):
                widget = QWidget()
                gridLayout.addWidget(widget)
                widget.setFixedHeight(50)
                hlayout = QHBoxLayout()
                widget.setLayout(hlayout)
                spacerLeft = QSpacerItem(int(self.centralwidget.parent().width()/2)-30,20,QSizePolicy.Policy.Expanding,QSizePolicy.Policy.Expanding)
                hlayout.addSpacerItem(spacerLeft)
                spacerRight = QSpacerItem(int(self.centralwidget.parent().width()/2)-30,20,QSizePolicy.Policy.Expanding,QSizePolicy.Policy.Expanding)
                pushButton = QPushButton()
                hlayout.addWidget(pushButton)
                hlayout.addSpacerItem(spacerRight)
                pushButton.setText(tabStructure[groupBoxLabel]["text"])
                callback_function = getattr(ui, tabStructure[groupBoxLabel]["callback"], None)
                pushButton.clicked.connect(callback_function)
            elif(groupBoxLabel != "deployButton"):
                verticalLayout = QtWidgets.QVBoxLayout()
                verticalLayout.setObjectName("verticalLayout")
                groupBox = QtWidgets.QGroupBox(groupBoxLabel,tab)
                groupBox.setObjectName(groupBoxLabel)
                verticalLayout.addWidget(groupBox)
                gridLayout.addLayout(verticalLayout, row, 0)

                if(tabStructure[groupBoxLabel]["treeView"] == True):
                    self.createTreeView(groupBox,tabStructure[groupBoxLabel])
                else:
                    self.createNonTreeView(groupBox,tabStructure[groupBoxLabel])


    def createTreeView(self,groupBox,viewStructure):
        treeModel = QStandardItemModel()
        treeView = QTreeView(groupBox)
        treeView.setModel(treeModel)
        layout = QVBoxLayout()
        layout.addWidget(treeView)
        groupBox.setLayout(layout)
        if(viewStructure["read"] == True):
            self.connectToMQTT()
            treeModel.setHorizontalHeaderLabels(viewStructure["columns"])
            for i in range(len(viewStructure["columns"])):
                treeView.setColumnWidth(i,int(self.centralwidget.parent().width()/len(viewStructure["columns"])))
            if(viewStructure["name"] == "master"):
                treeModelsList["master"] = treeModel
                self.received_message_master
                pass
            elif(viewStructure["name"] == "slave"):
                treeModelsList["slave"] = treeModel
                self.received_message_slave
                pass
        else:
            treeModel.setHorizontalHeaderLabels(viewStructure["columns"])
            if(viewStructure["rows"] != None):
                for i,item in enumerate(viewStructure["rows"]):
                    if(viewStructure["icons"] == False):
                        for j,colItm in enumerate(item):
                            valueItem = QStandardItem()
                            valueItem.setText(str(colItm))
                            treeModel.setItem(i,j,valueItem)
                    else:
                        for j,colItm in enumerate(item):
                            valueItem = QStandardItem()
                            key = next(iter(colItm.keys()))
                            valueItem.setText(key)
                            icon = colItm[key]
                            if(icon != None):
                                stateIcon = QtGui.QIcon()
                                stateIcon.addPixmap(QtGui.QPixmap(icon), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                                valueItem.setIcon(stateIcon)
                            treeModel.setItem(i,j,valueItem)

    def createNonTreeView(self,groupBox,viewStructure):
        global vLayout
        vLayout = QVBoxLayout()
        global dictLabels
        dictLabels = {}
        
        if(viewStructure["read"] == True):
            pass
        else:
            field_labels = list(viewStructure["fields"].keys())
            
            for label in field_labels:
                horizontal_layout = QHBoxLayout()
                dictFields = viewStructure["fields"]
                label_widget = QLabel(dictFields[label]["labelName"])
                dictLabels[dictFields[label]["labelName"]] = label

                if(dictFields[label]["checkbox"]==True):
                    checkbox = QCheckBox()
                    checkbox.setText(dictFields[label]["checkBoxText"])
                    horizontal_layout.addWidget(label_widget)
                    horizontal_layout.addWidget(checkbox)
                    vLayout.addLayout(horizontal_layout)
                elif(dictFields[label]["Text"] == False):
                    button = QPushButton('Select an option')
                    menu = QMenu(button)
                    global optionsDict
                    optionsDict = dictFields[label]["Options"]
                    options = list(optionsDict.keys())
                    for option in options:
                        action = QAction(option, self)
                        action.triggered.connect(lambda checked, option=option, button=button: self.update_button_text(option, button))
                        menu.addAction(action)

                    button.setMenu(menu)
                    horizontal_layout.addWidget(label_widget)
                    horizontal_layout.addWidget(button)
                    vLayout.addLayout(horizontal_layout)
                elif(dictFields[label]["replica"] == True):
                    lineEdit = QLineEdit()
                    lineEdit.setPlaceholderText("Type Text")
                    lineEdit.setMaximumHeight(20)
                    lineEdit.setSizePolicy(QSizePolicy.Policy.Preferred,QSizePolicy.Policy.Minimum)
                    horizontal_layout.addWidget(label_widget)
                    horizontalNestedLayout = QHBoxLayout()
                    horizontal_layout.addLayout(horizontalNestedLayout)
                    horizontalNestedLayout.addWidget(lineEdit)
                    pushButtonReplica = QPushButton()
                    pushButtonReplica.setText(dictFields[label]["buttonText"])
                    horizontalNestedLayout.addWidget(pushButtonReplica)
                    callback_function = getattr(ui, dictFields[label]["buttonCallBack"], None)
                    labelName = dictFields[label]["replicaText"]
                    labelDeployName = dictFields[label]["labelTextNames"]
                    global lstLayouts 
                    lstLayouts = []
                    pushButtonReplica.clicked.connect(lambda: callback_function(lineEdit,vLayout,labelName,labelDeployName))
                    vLayout.addLayout(horizontal_layout)
                else:
                    lineEdit = QLineEdit()
                    lineEdit.setPlaceholderText("Type Text")
                    lineEdit.setMaximumHeight(20)
                    lineEdit.setSizePolicy(QSizePolicy.Policy.Preferred,QSizePolicy.Policy.Minimum)
                    horizontal_layout.addWidget(label_widget)
                    horizontal_layout.addWidget(lineEdit)
                    vLayout.addLayout(horizontal_layout)

            groupBox.setLayout(vLayout)

    def update_button_text(self, option, button):
        button.setText(option)
    
    def showSlaves(self,lineedit,vlayout,replicaText,lblName):
        #Clear existing layouts first
        for layout in lstLayouts:
            for index in range(layout.count(),-1,-1):
                # print("index: ",index)
                widgetItem = layout.itemAt(index)
                # print("Item: ",widgetItem)
                if(widgetItem is not None and widgetItem.widget() is not None):
                    layout.removeWidget(widgetItem.widget())
            vlayout.removeItem(layout)
        if(lineedit.text() != ""):
            number = int(lineedit.text())
            for i in range(number):
                hlayout=QHBoxLayout()
                lstLayouts.append(hlayout)
                lbl = QLabel()
                lbl.setText(replicaText+str(i))
                dictLabels[lbl.text()] = lblName+str(i)
                lineEdit = QLineEdit()
                lineEdit.setPlaceholderText("Type Text")
                lineEdit.setMaximumHeight(20)
                lineEdit.setSizePolicy(QSizePolicy.Policy.Preferred,QSizePolicy.Policy.Minimum)
                hlayout.addWidget(lbl)
                hlayout.addWidget(lineEdit)
                vlayout.addLayout(hlayout)

    def on_message(self,client, userdata, msg):
        payload = msg.payload.decode("utf-8")
        try:
            # Try parsing the payload as JSON
            data = json.loads(payload)
            if(msg.topic == topics[0]):
                self.received_message_slave = data
                self.updateModel(treeModelsList["slave"],self.received_message_slave,"slave")
            elif(msg.topic == topics[1]):
                self.received_message_master = data
                self.updateModel(treeModelsList["master"],self.received_message_master,"master")
            print(f'Received JSON message: {data}')
        except json.JSONDecodeError:
            print(f'Received non-JSON message: {payload}')
        print(self.received_message_slave)
        print(self.received_message_master)
        
    def updateModel(self,treeModel,msg,stringDevice):
        if(stringDevice == "slave"):
            itmList = []
            for item in list(msg.values()):
                itm = None
                if(isinstance(item,str) or isinstance(item,int)):
                    itm = QStandardItem(str(item))
                else:
                    dictionary_string = json.dumps(item)
                    dictionary_string = dictionary_string[1:len(dictionary_string)-1]
                    itm = QStandardItem(dictionary_string)
                itmList.append(itm)
            
            rowInd = int(itmList[0].text()) if is_convertible_to_int(itmList[0].text()) else treeModel.rowCount()
            for colInd,item in enumerate(itmList):
                print("Item text: ",item.text())
                if(colInd == 1 and item.text() in list(dictSignalState.keys()) and dictSignalIcon[dictSignalState[item.text()]] is not None):
                    iconPath = dictSignalIcon[dictSignalState[item.text()]]
                    signalIcon = QtGui.QIcon()
                    signalIcon.addPixmap(QtGui.QPixmap(iconPath), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    item.setText(dictSignalState[item.text()])
                    item.setIcon(signalIcon)
                treeModel.setItem(rowInd,colInd,item)
            statusIcon = QtGui.QIcon()
            statusIcon.addPixmap(QtGui.QPixmap("icons/icon_green.png"), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            statusItem = QStandardItem("Healthy")
            statusItem.setIcon(statusIcon)
            treeModel.setItem(rowInd,4,statusItem)
        else:
            itmList = []
            for rowInd,key in enumerate(list(msg.keys())):
                itemState = QStandardItem(dictMasterKeys[key]) if key in dictMasterKeys else QStandardItem(key)
                treeModel.setItem(rowInd,0,itemState)
                value = msg[key]
                if(isinstance(value,dict)):
                    for ind,childKey in enumerate(value):
                        childItemKey = QStandardItem(str(childKey))
                        childItemValue = QStandardItem(str(value[childKey]))
                        itemState.setChild(ind,0,childItemKey)
                        itemState.setChild(ind,1,childItemValue)
                # elif(key == "Number")
                else:
                    valueItem = QStandardItem(str(value))
                    treeModel.setItem(rowInd,1,valueItem)            

    def connectToMQTT(self):
        self.statusLabel.setText("Connecting")
        # Call a method to update the status bar message
        if(client.is_connected() != True):
            try:
                rc = client.connect(broker,port,60)
                if(rc != 0):
                    self.statusLabel.setText("Could not connect!")
                else:
                    self.statusLabel.setText("Connected!")

            except BaseException:
                self.statusLabel.setText("Could not connect!")
                client.disconnect()
                

    def deployToBroker(self):
        json_string = {}
        for hlayout in vLayout.children():
            key = hlayout.itemAt(0).widget().text()
            if(dictLabels[key] is not None):
                key = dictLabels[key]
            # print(hlayout.itemAt(1).widget())
            value = ""
            if(isinstance(hlayout.itemAt(1).widget(),QLineEdit) or isinstance(hlayout.itemAt(1).widget(),QPushButton)):
                value = hlayout.itemAt(1).widget().text()
                # print("valueHereFirst: ",value)
            elif(isinstance(hlayout.itemAt(1).widget(),QCheckBox)):
                value = "1" if hlayout.itemAt(1).widget().isChecked() else "0"
            elif(isinstance(hlayout.itemAt(1),QHBoxLayout)):
                lout = hlayout.itemAt(1)
                # print("lout: ",lout)
                value = lout.itemAt(0).widget().text()
            if(value in list(optionsDict.keys())):
                value = optionsDict[value]
            # print("value: ",value)
            if(value == 'Select an option' or value == ''):
                popup = QMessageBox()
                popup.setWindowTitle("Invalid Parameters Set!")
                popup.setText("You have selected the parameters properly. Please Check!")
                popup.setIcon(QMessageBox.Icon.Information)
                popup.addButton(QMessageBox.StandardButton.Ok)
                popup.addButton(QMessageBox.StandardButton.Cancel)
        
                result = popup.exec()
                
                if result == QMessageBox.StandardButton.Ok:
                    print("Ok button clicked")
                else:
                    print("Cancel button clicked")

                return

            json_string[key] = value
        print("Message: ",json_string)
        deployJSON = json.dumps(json_string)
        if(client.is_connected() != True):
            try:
                rc = client.connect(broker,port,60)
                if(rc != 0):
                    self.statusLabel.setText("Could not connect!")
            except BaseException:
                self.statusLabel.setText("Could not connect!")
                client.disconnect()
        result = client.publish("/traffic/updates",deployJSON)
        if(result.rc == mqtt.MQTT_ERR_SUCCESS):
            self.statusLabel.setText("Deployed!")
        else:
            self.statusLabel.setText("Could not deploy!")

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("Traffic Controller", "Traffic Controller"))

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    global ui,guiStructure
    guiStructure = read_json_file("GUIFrontEnd.json")
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    try:
        client.connect(broker,port,60)
        for topic in topics:
            client.subscribe(topic)
        client.on_message = ui.on_message
    except KeyboardInterrupt:
        print("Disconnecting...")
        client.disconnect()
    finally:
        client.loop_start()
        sys.exit(app.exec())